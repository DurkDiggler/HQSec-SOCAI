"""Vulnerability correlation system with CVE mapping and prioritization."""

from __future__ import annotations

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.cluster import DBSCAN

from ..config import SETTINGS
from ..database import get_db, get_historical_alerts, get_historical_incidents

logger = logging.getLogger(__name__)

class VulnerabilityCorrelator:
    """
    Vulnerability correlation system that maps CVEs to threats,
    prioritizes vulnerabilities, and correlates with attack patterns.
    """

    def __init__(self):
        self.cve_database = self._load_cve_database()
        self.exploit_database = self._load_exploit_database()
        self.asset_database = self._load_asset_database()
        self.threat_intelligence = self._load_threat_intelligence()
        self.prioritization_weights = self._load_prioritization_weights()

    def _load_cve_database(self) -> Dict[str, Dict[str, Any]]:
        """Loads CVE database with vulnerability information."""
        return {
            "CVE-2021-44228": {
                "id": "CVE-2021-44228",
                "name": "Apache Log4j Remote Code Execution",
                "description": "Apache Log4j2 2.0-beta9 through 2.15.0 (excluding security releases 2.12.2, 2.12.3, and 2.3.1) was affected by a remote code execution vulnerability",
                "severity": "CRITICAL",
                "cvss_score": 10.0,
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
                "cwe_id": "CWE-502",
                "cwe_name": "Deserialization of Untrusted Data",
                "affected_products": ["Apache Log4j", "Spring Boot", "Elasticsearch", "Solr"],
                "attack_vector": "Network",
                "attack_complexity": "Low",
                "privileges_required": "None",
                "user_interaction": "None",
                "scope": "Changed",
                "confidentiality_impact": "High",
                "integrity_impact": "High",
                "availability_impact": "High",
                "published_date": "2021-12-10",
                "last_modified": "2021-12-10",
                "references": [
                    "https://nvd.nist.gov/vuln/detail/CVE-2021-44228",
                    "https://logging.apache.org/log4j/2.x/security.html"
                ],
                "exploit_available": True,
                "exploit_maturity": "Functional",
                "patch_available": True,
                "workaround_available": True
            },
            "CVE-2021-34527": {
                "id": "CVE-2021-34527",
                "name": "Windows Print Spooler Remote Code Execution",
                "description": "Windows Print Spooler Remote Code Execution Vulnerability",
                "severity": "CRITICAL",
                "cvss_score": 9.8,
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                "cwe_id": "CWE-269",
                "cwe_name": "Improper Privilege Management",
                "affected_products": ["Windows 10", "Windows Server 2019", "Windows Server 2022"],
                "attack_vector": "Network",
                "attack_complexity": "Low",
                "privileges_required": "None",
                "user_interaction": "None",
                "scope": "Unchanged",
                "confidentiality_impact": "High",
                "integrity_impact": "High",
                "availability_impact": "High",
                "published_date": "2021-07-13",
                "last_modified": "2021-07-13",
                "references": [
                    "https://nvd.nist.gov/vuln/detail/CVE-2021-34527"
                ],
                "exploit_available": True,
                "exploit_maturity": "Functional",
                "patch_available": True,
                "workaround_available": True
            },
            "CVE-2020-1472": {
                "id": "CVE-2020-1472",
                "name": "Netlogon Elevation of Privilege",
                "description": "An elevation of privilege vulnerability exists when an attacker establishes a vulnerable Netlogon secure channel connection to a domain controller",
                "severity": "CRITICAL",
                "cvss_score": 10.0,
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                "cwe_id": "CWE-269",
                "cwe_name": "Improper Privilege Management",
                "affected_products": ["Windows Server 2016", "Windows Server 2019", "Windows Server 2022"],
                "attack_vector": "Network",
                "attack_complexity": "Low",
                "privileges_required": "None",
                "user_interaction": "None",
                "scope": "Unchanged",
                "confidentiality_impact": "High",
                "integrity_impact": "High",
                "availability_impact": "High",
                "published_date": "2020-08-11",
                "last_modified": "2020-08-11",
                "references": [
                    "https://nvd.nist.gov/vuln/detail/CVE-2020-1472"
                ],
                "exploit_available": True,
                "exploit_maturity": "Functional",
                "patch_available": True,
                "workaround_available": True
            },
            "CVE-2019-0708": {
                "id": "CVE-2019-0708",
                "name": "Remote Desktop Services Remote Code Execution",
                "description": "A remote code execution vulnerability exists in Remote Desktop Services when an unauthenticated attacker connects to the target system using RDP",
                "severity": "CRITICAL",
                "cvss_score": 9.8,
                "cvss_vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                "cwe_id": "CWE-20",
                "cwe_name": "Improper Input Validation",
                "affected_products": ["Windows 7", "Windows Server 2008", "Windows Server 2008 R2"],
                "attack_vector": "Network",
                "attack_complexity": "Low",
                "privileges_required": "None",
                "user_interaction": "None",
                "scope": "Unchanged",
                "confidentiality_impact": "High",
                "integrity_impact": "High",
                "availability_impact": "High",
                "published_date": "2019-05-14",
                "last_modified": "2019-05-14",
                "references": [
                    "https://nvd.nist.gov/vuln/detail/CVE-2019-0708"
                ],
                "exploit_available": True,
                "exploit_maturity": "Functional",
                "patch_available": True,
                "workaround_available": True
            }
        }

    def _load_exploit_database(self) -> Dict[str, Dict[str, Any]]:
        """Loads exploit database with exploit information."""
        return {
            "CVE-2021-44228": {
                "cve_id": "CVE-2021-44228",
                "exploit_name": "Log4Shell",
                "exploit_type": "Remote Code Execution",
                "exploit_platform": "Java",
                "exploit_language": "Java",
                "exploit_complexity": "Low",
                "exploit_reliability": "High",
                "exploit_availability": "Public",
                "exploit_maturity": "Functional",
                "exploit_source": "GitHub",
                "exploit_url": "https://github.com/tangxiaofeng7/apache-log4j-poc",
                "exploit_date": "2021-12-10",
                "exploit_author": "Unknown",
                "exploit_description": "Proof of concept exploit for Apache Log4j RCE vulnerability",
                "exploit_requirements": ["Java application with Log4j", "Network access"],
                "exploit_impact": "Remote code execution with system privileges"
            },
            "CVE-2021-34527": {
                "cve_id": "CVE-2021-34527",
                "exploit_name": "PrintNightmare",
                "exploit_type": "Remote Code Execution",
                "exploit_platform": "Windows",
                "exploit_language": "C++",
                "exploit_complexity": "Low",
                "exploit_reliability": "High",
                "exploit_availability": "Public",
                "exploit_maturity": "Functional",
                "exploit_source": "GitHub",
                "exploit_url": "https://github.com/cube0x0/CVE-2021-1675",
                "exploit_date": "2021-07-13",
                "exploit_author": "cube0x0",
                "exploit_description": "Exploit for Windows Print Spooler RCE vulnerability",
                "exploit_requirements": ["Windows system with Print Spooler", "Network access"],
                "exploit_impact": "Remote code execution with system privileges"
            }
        }

    def _load_asset_database(self) -> Dict[str, Dict[str, Any]]:
        """Loads asset database with asset information."""
        return {
            "web_server_01": {
                "id": "web_server_01",
                "name": "Web Server 01",
                "type": "Web Server",
                "os": "Ubuntu 20.04",
                "ip_address": "192.168.1.10",
                "mac_address": "00:11:22:33:44:55",
                "hostname": "web01.company.com",
                "criticality": "High",
                "business_function": "Customer Portal",
                "owner": "IT Department",
                "location": "Data Center A",
                "installed_software": [
                    "Apache HTTP Server 2.4.41",
                    "Java 11.0.12",
                    "Log4j 2.14.1",
                    "Spring Boot 2.5.5"
                ],
                "open_ports": [80, 443, 22, 8080],
                "vulnerabilities": ["CVE-2021-44228"],
                "last_scan": "2021-12-15",
                "patch_status": "Outdated"
            },
            "db_server_01": {
                "id": "db_server_01",
                "name": "Database Server 01",
                "type": "Database Server",
                "os": "Windows Server 2019",
                "ip_address": "192.168.1.20",
                "mac_address": "00:11:22:33:44:66",
                "hostname": "db01.company.com",
                "criticality": "Critical",
                "business_function": "Customer Database",
                "owner": "IT Department",
                "location": "Data Center A",
                "installed_software": [
                    "Microsoft SQL Server 2019",
                    "Windows Server 2019",
                    "IIS 10.0"
                ],
                "open_ports": [1433, 3389, 80, 443],
                "vulnerabilities": ["CVE-2021-34527"],
                "last_scan": "2021-12-15",
                "patch_status": "Outdated"
            },
            "workstation_01": {
                "id": "workstation_01",
                "name": "Workstation 01",
                "type": "Workstation",
                "os": "Windows 10",
                "ip_address": "192.168.1.30",
                "mac_address": "00:11:22:33:44:77",
                "hostname": "ws01.company.com",
                "criticality": "Medium",
                "business_function": "Development",
                "owner": "Development Team",
                "location": "Office Building B",
                "installed_software": [
                    "Windows 10",
                    "Visual Studio 2019",
                    "Chrome Browser",
                    "Office 365"
                ],
                "open_ports": [3389, 80, 443],
                "vulnerabilities": [],
                "last_scan": "2021-12-15",
                "patch_status": "Current"
            }
        }

    def _load_threat_intelligence(self) -> Dict[str, List[str]]:
        """Loads threat intelligence feeds."""
        return {
            "active_campaigns": [
                "CVE-2021-44228",
                "CVE-2021-34527",
                "CVE-2020-1472"
            ],
            "exploited_in_wild": [
                "CVE-2021-44228",
                "CVE-2021-34527"
            ],
            "ransomware_groups": [
                "CVE-2021-44228",
                "CVE-2020-1472"
            ],
            "apt_groups": [
                "CVE-2021-44228",
                "CVE-2020-1472"
            ]
        }

    def _load_prioritization_weights(self) -> Dict[str, float]:
        """Loads prioritization weights for vulnerability scoring."""
        return {
            "cvss_score": 0.25,
            "exploit_available": 0.20,
            "exploit_maturity": 0.15,
            "threat_intelligence": 0.15,
            "asset_criticality": 0.10,
            "patch_availability": 0.05,
            "workaround_availability": 0.05,
            "age_factor": 0.05
        }

    async def correlate_vulnerabilities(self, 
                                      asset_id: str = None,
                                      time_window_days: int = 30) -> Dict[str, Any]:
        """
        Correlates vulnerabilities with threats and prioritizes them.
        
        Args:
            asset_id: Specific asset to analyze (all if None)
            time_window_days: Time window for threat correlation
            
        Returns:
            Vulnerability correlation results
        """
        try:
            logger.info(f"Starting vulnerability correlation analysis for asset {asset_id or 'all'}")
            
            # Get assets to analyze
            if asset_id:
                assets = [self.asset_database.get(asset_id)] if asset_id in self.asset_database else []
            else:
                assets = list(self.asset_database.values())
            
            if not assets:
                return {"error": "No assets found for analysis"}
            
            # Analyze each asset
            correlation_results = []
            
            for asset in assets:
                if not asset:
                    continue
                
                asset_analysis = await self._analyze_asset_vulnerabilities(asset, time_window_days)
                correlation_results.append(asset_analysis)
            
            # Generate overall correlation report
            correlation_report = {
                "analysis_time": datetime.utcnow().isoformat(),
                "time_window_days": time_window_days,
                "total_assets": len(assets),
                "vulnerable_assets": len([r for r in correlation_results if r["vulnerabilities"]]),
                "total_vulnerabilities": sum(len(r["vulnerabilities"]) for r in correlation_results),
                "critical_vulnerabilities": sum(len([v for v in r["vulnerabilities"] if v["severity"] == "CRITICAL"]) for r in correlation_results),
                "exploitable_vulnerabilities": sum(len([v for v in r["vulnerabilities"] if v["exploit_available"]]) for r in correlation_results),
                "asset_analyses": correlation_results,
                "prioritized_vulnerabilities": await self._prioritize_vulnerabilities(correlation_results),
                "recommendations": await self._generate_vulnerability_recommendations(correlation_results)
            }
            
            logger.info(f"Vulnerability correlation completed: {correlation_report['total_vulnerabilities']} vulnerabilities found")
            return correlation_report
            
        except Exception as e:
            logger.error(f"Error in vulnerability correlation: {e}")
            return {
                "error": str(e),
                "analysis_time": datetime.utcnow().isoformat()
            }

    async def _analyze_asset_vulnerabilities(self, 
                                           asset: Dict[str, Any], 
                                           time_window_days: int) -> Dict[str, Any]:
        """Analyzes vulnerabilities for a specific asset."""
        asset_id = asset["id"]
        vulnerabilities = asset.get("vulnerabilities", [])
        
        analysis = {
            "asset_id": asset_id,
            "asset_name": asset["name"],
            "asset_type": asset["type"],
            "asset_criticality": asset["criticality"],
            "vulnerabilities": [],
            "risk_score": 0.0,
            "patch_status": asset.get("patch_status", "Unknown"),
            "last_scan": asset.get("last_scan", "Unknown")
        }
        
        # Analyze each vulnerability
        for cve_id in vulnerabilities:
            if cve_id in self.cve_database:
                cve_info = self.cve_database[cve_id]
                exploit_info = self.exploit_database.get(cve_id, {})
                
                # Calculate vulnerability score
                vuln_score = await self._calculate_vulnerability_score(
                    cve_info, exploit_info, asset, time_window_days
                )
                
                vulnerability_analysis = {
                    "cve_id": cve_id,
                    "name": cve_info["name"],
                    "description": cve_info["description"],
                    "severity": cve_info["severity"],
                    "cvss_score": cve_info["cvss_score"],
                    "cvss_vector": cve_info["cvss_vector"],
                    "cwe_id": cve_info["cwe_id"],
                    "cwe_name": cve_info["cwe_name"],
                    "affected_products": cve_info["affected_products"],
                    "exploit_available": cve_info.get("exploit_available", False),
                    "exploit_maturity": exploit_info.get("exploit_maturity", "Unknown"),
                    "patch_available": cve_info.get("patch_available", False),
                    "workaround_available": cve_info.get("workaround_available", False),
                    "threat_intelligence": await self._get_threat_intelligence(cve_id),
                    "vulnerability_score": vuln_score,
                    "risk_level": self._determine_risk_level(vuln_score),
                    "recommendations": await self._generate_vulnerability_recommendations_single(cve_info, exploit_info, asset)
                }
                
                analysis["vulnerabilities"].append(vulnerability_analysis)
        
        # Calculate overall asset risk score
        if analysis["vulnerabilities"]:
            analysis["risk_score"] = max(v["vulnerability_score"] for v in analysis["vulnerabilities"])
        
        # Sort vulnerabilities by score
        analysis["vulnerabilities"].sort(key=lambda x: x["vulnerability_score"], reverse=True)
        
        return analysis

    async def _calculate_vulnerability_score(self, 
                                           cve_info: Dict[str, Any], 
                                           exploit_info: Dict[str, Any], 
                                           asset: Dict[str, Any], 
                                           time_window_days: int) -> float:
        """Calculates a comprehensive vulnerability score."""
        weights = self.prioritization_weights
        
        # Base CVSS score (normalized to 0-1)
        cvss_score = cve_info["cvss_score"] / 10.0
        
        # Exploit availability score
        exploit_score = 0.0
        if cve_info.get("exploit_available", False):
            exploit_score = 1.0
            if exploit_info.get("exploit_maturity") == "Functional":
                exploit_score = 1.0
            elif exploit_info.get("exploit_maturity") == "Proof of Concept":
                exploit_score = 0.7
            elif exploit_info.get("exploit_maturity") == "Theoretical":
                exploit_score = 0.3
        
        # Threat intelligence score
        threat_intel_score = 0.0
        cve_id = cve_info["id"]
        if cve_id in self.threat_intelligence["active_campaigns"]:
            threat_intel_score += 0.3
        if cve_id in self.threat_intelligence["exploited_in_wild"]:
            threat_intel_score += 0.4
        if cve_id in self.threat_intelligence["ransomware_groups"]:
            threat_intel_score += 0.2
        if cve_id in self.threat_intelligence["apt_groups"]:
            threat_intel_score += 0.1
        
        # Asset criticality score
        criticality_scores = {"Low": 0.2, "Medium": 0.5, "High": 0.8, "Critical": 1.0}
        asset_criticality_score = criticality_scores.get(asset["criticality"], 0.5)
        
        # Patch availability score (inverse - easier to patch = lower score)
        patch_score = 0.0
        if cve_info.get("patch_available", False):
            patch_score = 0.3  # Lower score if patch is available
        if cve_info.get("workaround_available", False):
            patch_score = 0.5  # Medium score if workaround is available
        
        # Age factor (older vulnerabilities get higher scores)
        published_date = datetime.fromisoformat(cve_info["published_date"])
        age_days = (datetime.utcnow() - published_date).days
        age_score = min(age_days / 365, 1.0)  # Normalize to 1 year
        
        # Calculate weighted score
        total_score = (
            cvss_score * weights["cvss_score"] +
            exploit_score * weights["exploit_available"] +
            threat_intel_score * weights["threat_intelligence"] +
            asset_criticality_score * weights["asset_criticality"] +
            patch_score * weights["patch_availability"] +
            age_score * weights["age_factor"]
        )
        
        return min(total_score, 1.0)  # Cap at 1.0

    async def _get_threat_intelligence(self, cve_id: str) -> Dict[str, Any]:
        """Gets threat intelligence information for a CVE."""
        return {
            "active_campaigns": cve_id in self.threat_intelligence["active_campaigns"],
            "exploited_in_wild": cve_id in self.threat_intelligence["exploited_in_wild"],
            "ransomware_groups": cve_id in self.threat_intelligence["ransomware_groups"],
            "apt_groups": cve_id in self.threat_intelligence["apt_groups"]
        }

    def _determine_risk_level(self, score: float) -> str:
        """Determines risk level based on vulnerability score."""
        if score >= 0.8:
            return "Critical"
        elif score >= 0.6:
            return "High"
        elif score >= 0.4:
            return "Medium"
        else:
            return "Low"

    async def _generate_vulnerability_recommendations_single(self, 
                                                           cve_info: Dict[str, Any], 
                                                           exploit_info: Dict[str, Any], 
                                                           asset: Dict[str, Any]) -> List[str]:
        """Generates recommendations for a single vulnerability."""
        recommendations = []
        
        # Patch recommendations
        if cve_info.get("patch_available", False):
            recommendations.append("Apply available security patch immediately")
        elif cve_info.get("workaround_available", False):
            recommendations.append("Implement available workaround")
        else:
            recommendations.append("Monitor for patch availability and consider compensating controls")
        
        # Exploit-specific recommendations
        if cve_info.get("exploit_available", False):
            recommendations.append("High priority - exploit is available")
            if exploit_info.get("exploit_maturity") == "Functional":
                recommendations.append("Critical priority - functional exploit available")
        
        # Threat intelligence recommendations
        if cve_info["id"] in self.threat_intelligence["active_campaigns"]:
            recommendations.append("Active in current threat campaigns - immediate attention required")
        
        if cve_info["id"] in self.threat_intelligence["exploited_in_wild"]:
            recommendations.append("Confirmed exploitation in the wild - urgent patching required")
        
        # Asset-specific recommendations
        if asset["criticality"] == "Critical":
            recommendations.append("Critical asset - prioritize patching")
        elif asset["criticality"] == "High":
            recommendations.append("High-value asset - expedite patching")
        
        # General recommendations
        recommendations.append("Implement network segmentation to limit blast radius")
        recommendations.append("Monitor for exploitation attempts")
        recommendations.append("Consider temporary workarounds if patching is not immediately possible")
        
        return recommendations

    async def _prioritize_vulnerabilities(self, 
                                        correlation_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Prioritizes vulnerabilities across all assets."""
        all_vulnerabilities = []
        
        for asset_analysis in correlation_results:
            for vulnerability in asset_analysis["vulnerabilities"]:
                vulnerability["asset_id"] = asset_analysis["asset_id"]
                vulnerability["asset_name"] = asset_analysis["asset_name"]
                vulnerability["asset_criticality"] = asset_analysis["asset_criticality"]
                all_vulnerabilities.append(vulnerability)
        
        # Sort by vulnerability score
        all_vulnerabilities.sort(key=lambda x: x["vulnerability_score"], reverse=True)
        
        return all_vulnerabilities

    async def _generate_vulnerability_recommendations(self, 
                                                    correlation_results: List[Dict[str, Any]]) -> List[str]:
        """Generates overall recommendations for vulnerability management."""
        recommendations = []
        
        # Count vulnerabilities by severity
        critical_count = sum(len([v for v in r["vulnerabilities"] if v["severity"] == "CRITICAL"]) for r in correlation_results)
        high_count = sum(len([v for v in r["vulnerabilities"] if v["severity"] == "HIGH"]) for r in correlation_results)
        exploitable_count = sum(len([v for v in r["vulnerabilities"] if v["exploit_available"]]) for r in correlation_results)
        
        # Generate recommendations based on findings
        if critical_count > 0:
            recommendations.append(f"Immediate action required: {critical_count} critical vulnerabilities found")
        
        if exploitable_count > 0:
            recommendations.append(f"High priority: {exploitable_count} vulnerabilities have available exploits")
        
        if high_count > 0:
            recommendations.append(f"Address {high_count} high-severity vulnerabilities within 30 days")
        
        # General recommendations
        recommendations.append("Implement a regular vulnerability scanning schedule")
        recommendations.append("Establish a patch management process")
        recommendations.append("Consider implementing a vulnerability management program")
        recommendations.append("Regularly review and update security controls")
        
        return recommendations

    async def get_vulnerability_trends(self, 
                                     time_window_days: int = 90) -> Dict[str, Any]:
        """Analyzes vulnerability trends over time."""
        try:
            # This would typically query historical data
            # For now, we'll simulate trend analysis
            trends = {
                "time_window_days": time_window_days,
                "total_vulnerabilities": len(self.cve_database),
                "critical_vulnerabilities": len([cve for cve in self.cve_database.values() if cve["severity"] == "CRITICAL"]),
                "exploitable_vulnerabilities": len([cve for cve in self.cve_database.values() if cve.get("exploit_available", False)]),
                "trend_analysis": {
                    "vulnerability_discovery_rate": "Increasing",
                    "exploit_development_rate": "Stable",
                    "patch_availability_rate": "Improving"
                },
                "top_cvss_scores": sorted([cve["cvss_score"] for cve in self.cve_database.values()], reverse=True)[:10],
                "most_common_cwe": ["CWE-269", "CWE-20", "CWE-502"],
                "analysis_date": datetime.utcnow().isoformat()
            }
            
            return trends
            
        except Exception as e:
            logger.error(f"Error analyzing vulnerability trends: {e}")
            return {"error": str(e)}

    async def get_correlation_status(self) -> Dict[str, Any]:
        """Gets the current status of the vulnerability correlation system."""
        return {
            "cve_database_size": len(self.cve_database),
            "exploit_database_size": len(self.exploit_database),
            "asset_database_size": len(self.asset_database),
            "threat_intelligence_feeds": len(self.threat_intelligence),
            "last_updated": datetime.utcnow().isoformat()
        }
