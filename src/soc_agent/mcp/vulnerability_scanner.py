"""Vulnerability Scanner MCP Server integration."""

from __future__ import annotations

import json
import logging
from typing import Any, Dict, List, Optional

import aiohttp

from ..config import SETTINGS

logger = logging.getLogger(__name__)


class VulnerabilityMCPServer:
    """Integration with Vulnerability Scanner MCP Server."""
    
    def __init__(self):
        self.base_url = getattr(SETTINGS, 'vuln_scanner_url', 'http://localhost:5001')
        self.timeout = getattr(SETTINGS, 'mcp_timeout', 30)
        self.session = None
    
    async def execute_command(
        self, 
        command: str, 
        parameters: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Execute a command on the Vulnerability Scanner MCP server."""
        try:
            if not self.session:
                self.session = aiohttp.ClientSession()
            
            # Build command based on type
            cmd = self._build_command(command, parameters or {})
            
            # Execute via MCP server
            async with self.session.post(
                f"{self.base_url}/run",
                json={"cmd": cmd},
                timeout=aiohttp.ClientTimeout(total=self.timeout)
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    return {
                        "success": True,
                        "command": cmd,
                        "output": result.get("output", ""),
                        "server": "vulnerability_scanner"
                    }
                else:
                    error_text = await response.text()
                    return {
                        "success": False,
                        "error": f"HTTP {response.status}: {error_text}",
                        "command": cmd,
                        "server": "vulnerability_scanner"
                    }
                    
        except Exception as e:
            logger.error(f"Vulnerability Scanner MCP command execution failed: {e}")
            return {
                "success": False,
                "error": str(e),
                "command": command,
                "server": "vulnerability_scanner"
            }
    
    def _build_command(self, command: str, parameters: Dict[str, Any]) -> str:
        """Build the actual command to execute."""
        if command == "vuln_scan":
            return self._build_vuln_scan_command(parameters)
        elif command == "cve_lookup":
            return self._build_cve_lookup_command(parameters)
        elif command == "exploit_check":
            return self._build_exploit_check_command(parameters)
        elif command == "patch_analysis":
            return self._build_patch_analysis_command(parameters)
        else:
            return command
    
    def _build_vuln_scan_command(self, parameters: Dict[str, Any]) -> str:
        """Build vulnerability scan command."""
        target = parameters.get("target", "localhost")
        scan_type = parameters.get("scan_type", "basic")
        
        if scan_type == "openvas":
            return f"openvas-cli --target {target} --scan"
        elif scan_type == "nessus":
            return f"nessus-cli scan --target {target}"
        elif scan_type == "nmap_vuln":
            return f"nmap --script vuln {target}"
        else:
            return f"nmap --script vuln {target}"
    
    def _build_cve_lookup_command(self, parameters: Dict[str, Any]) -> str:
        """Build CVE lookup command."""
        cve_id = parameters.get("cve_id", "")
        if cve_id:
            return f"curl -s 'https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}'"
        else:
            return "echo 'CVE ID required'"
    
    def _build_exploit_check_command(self, parameters: Dict[str, Any]) -> str:
        """Build exploit check command."""
        vulnerability = parameters.get("vulnerability", "")
        if vulnerability:
            return f"searchsploit {vulnerability}"
        else:
            return "echo 'Vulnerability name required'"
    
    def _build_patch_analysis_command(self, parameters: Dict[str, Any]) -> str:
        """Build patch analysis command."""
        target = parameters.get("target", "localhost")
        return f"nmap --script vuln --script-args vulns.showall {target}"
    
    async def vuln_scan(
        self, 
        target: str, 
        scan_type: str = "basic"
    ) -> Dict[str, Any]:
        """Perform vulnerability scan."""
        parameters = {
            "target": target,
            "scan_type": scan_type
        }
        return await self.execute_command("vuln_scan", parameters)
    
    async def cve_lookup(self, cve_id: str) -> Dict[str, Any]:
        """Look up CVE information."""
        parameters = {"cve_id": cve_id}
        return await self.execute_command("cve_lookup", parameters)
    
    async def exploit_check(self, vulnerability: str) -> Dict[str, Any]:
        """Check for available exploits."""
        parameters = {"vulnerability": vulnerability}
        return await self.execute_command("exploit_check", parameters)
    
    async def patch_analysis(self, target: str) -> Dict[str, Any]:
        """Analyze patch status."""
        parameters = {"target": target}
        return await self.execute_command("patch_analysis", parameters)
    
    async def get_status(self) -> Dict[str, Any]:
        """Get server status."""
        try:
            if not self.session:
                self.session = aiohttp.ClientSession()
            
            async with self.session.get(
                f"{self.base_url}/status",
                timeout=aiohttp.ClientTimeout(total=5)
            ) as response:
                if response.status == 200:
                    return {"status": "online", "response_time": "< 1s"}
                else:
                    return {"status": "error", "code": response.status}
                    
        except Exception as e:
            return {"status": "offline", "error": str(e)}
    
    def get_available_commands(self) -> List[str]:
        """Get available commands."""
        return [
            "vuln_scan",
            "cve_lookup",
            "exploit_check",
            "patch_analysis"
        ]
    
    def get_capabilities(self) -> Dict[str, Any]:
        """Get server capabilities."""
        return {
            "name": "Vulnerability Scanner MCP Server",
            "version": "1.0.0",
            "tools": [
                "nmap", "openvas", "nessus", "searchsploit"
            ],
            "scan_types": [
                "vulnerability_scan", "cve_lookup", "exploit_check",
                "patch_analysis"
            ],
            "supported_targets": ["ip", "hostname", "url"],
            "max_targets": 100,
            "concurrent_scans": 5
        }
    
    async def close(self):
        """Close the session."""
        if self.session:
            await self.session.close()
            self.session = None
